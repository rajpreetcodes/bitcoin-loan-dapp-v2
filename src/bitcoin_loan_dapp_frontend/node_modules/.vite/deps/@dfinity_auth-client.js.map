{
  "version": 3,
  "sources": ["../../../../../node_modules/@dfinity/auth-client/src/idleManager.ts", "../../../../../node_modules/idb/build/wrap-idb-value.js", "../../../../../node_modules/idb/build/index.js", "../../../../../node_modules/@dfinity/auth-client/src/db.ts", "../../../../../node_modules/@dfinity/auth-client/src/storage.ts", "../../../../../node_modules/@dfinity/auth-client/src/index.ts"],
  "sourcesContent": ["/** @module IdleManager */\ntype IdleCB = () => unknown;\nexport type IdleManagerOptions = {\n  /**\n   * Callback after the user has gone idle\n   */\n  onIdle?: IdleCB;\n  /**\n   * timeout in ms\n   * @default 30 minutes [600_000]\n   */\n  idleTimeout?: number;\n  /**\n   * capture scroll events\n   * @default false\n   */\n  captureScroll?: boolean;\n  /**\n   * scroll debounce time in ms\n   * @default 100\n   */\n  scrollDebounce?: number;\n};\n\nconst events = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'wheel'];\n\n/**\n * Detects if the user has been idle for a duration of `idleTimeout` ms, and calls `onIdle` and registered callbacks.\n * By default, the IdleManager will log a user out after 10 minutes of inactivity.\n * To override these defaults, you can pass an `onIdle` callback, or configure a custom `idleTimeout` in milliseconds\n */\nexport class IdleManager {\n  callbacks: IdleCB[] = [];\n  idleTimeout: IdleManagerOptions['idleTimeout'] = 10 * 60 * 1000;\n  timeoutID?: number = undefined;\n\n  /**\n   * Creates an {@link IdleManager}\n   * @param {IdleManagerOptions} options Optional configuration\n   * @see {@link IdleManagerOptions}\n   * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user\n   * @param options.idleTimeout timeout in ms\n   * @param options.captureScroll capture scroll events\n   * @param options.scrollDebounce scroll debounce time in ms\n   */\n  public static create(\n    options: {\n      /**\n       * Callback after the user has gone idle\n       * @see {@link IdleCB}\n       */\n      onIdle?: () => unknown;\n      /**\n       * timeout in ms\n       * @default 10 minutes [600_000]\n       */\n      idleTimeout?: number;\n      /**\n       * capture scroll events\n       * @default false\n       */\n      captureScroll?: boolean;\n      /**\n       * scroll debounce time in ms\n       * @default 100\n       */\n      scrollDebounce?: number;\n    } = {},\n  ): IdleManager {\n    return new this(options);\n  }\n\n  /**\n   * @protected\n   * @param options {@link IdleManagerOptions}\n   */\n  protected constructor(options: IdleManagerOptions = {}) {\n    const { onIdle, idleTimeout = 10 * 60 * 1000 } = options || {};\n\n    this.callbacks = onIdle ? [onIdle] : [];\n    this.idleTimeout = idleTimeout;\n\n    const _resetTimer = this._resetTimer.bind(this);\n\n    window.addEventListener('load', _resetTimer, true);\n\n    events.forEach(function (name) {\n      document.addEventListener(name, _resetTimer, true);\n    });\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const debounce = (func: Function, wait: number) => {\n      let timeout: number | undefined;\n      return (...args: unknown[]) => {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const context = this;\n        const later = function () {\n          timeout = undefined;\n          func.apply(context, args);\n        };\n        clearTimeout(timeout);\n        timeout = window.setTimeout(later, wait);\n      };\n    };\n\n    if (options?.captureScroll) {\n      // debounce scroll events\n      const scroll = debounce(_resetTimer, options?.scrollDebounce ?? 100);\n      window.addEventListener('scroll', scroll, true);\n    }\n\n    _resetTimer();\n  }\n\n  /**\n   * @param {IdleCB} callback function to be called when user goes idle\n   */\n  public registerCallback(callback: IdleCB): void {\n    this.callbacks.push(callback);\n  }\n\n  /**\n   * Cleans up the idle manager and its listeners\n   */\n  public exit(): void {\n    clearTimeout(this.timeoutID);\n    window.removeEventListener('load', this._resetTimer, true);\n\n    const _resetTimer = this._resetTimer.bind(this);\n    events.forEach(function (name) {\n      document.removeEventListener(name, _resetTimer, true);\n    });\n    this.callbacks.forEach(cb => cb());\n  }\n\n  /**\n   * Resets the timeouts during cleanup\n   */\n  _resetTimer(): void {\n    const exit = this.exit.bind(this);\n    window.clearTimeout(this.timeoutID);\n    this.timeoutID = window.setTimeout(exit, this.idleTimeout);\n  }\n}\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "import { openDB, IDBPDatabase } from 'idb';\nimport { DB_VERSION, isBrowser, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\n\ntype Database = IDBPDatabase<unknown>;\ntype IDBValidKey = string | number | Date | BufferSource | IDBValidKey[];\nconst AUTH_DB_NAME = 'auth-client-db';\nconst OBJECT_STORE_NAME = 'ic-keyval';\n\nconst _openDbStore = async (\n  dbName = AUTH_DB_NAME,\n  storeName = OBJECT_STORE_NAME,\n  version: number,\n) => {\n  // Clear legacy stored delegations\n  if (isBrowser && localStorage?.getItem(KEY_STORAGE_DELEGATION)) {\n    localStorage.removeItem(KEY_STORAGE_DELEGATION);\n    localStorage.removeItem(KEY_STORAGE_KEY);\n  }\n  return await openDB(dbName, version, {\n    upgrade: database => {\n      database.objectStoreNames;\n      if (database.objectStoreNames.contains(storeName)) {\n        database.clear(storeName);\n      }\n      database.createObjectStore(storeName);\n    },\n  });\n};\n\nasync function _getValue<T>(\n  db: Database,\n  storeName: string,\n  key: IDBValidKey,\n): Promise<T | undefined> {\n  return await db.get(storeName, key);\n}\n\nasync function _setValue<T>(\n  db: Database,\n  storeName: string,\n  key: IDBValidKey,\n  value: T,\n): Promise<IDBValidKey> {\n  return await db.put(storeName, value, key);\n}\n\nasync function _removeValue(db: Database, storeName: string, key: IDBValidKey): Promise<void> {\n  return await db.delete(storeName, key);\n}\n\nexport type DBCreateOptions = {\n  dbName?: string;\n  storeName?: string;\n  version?: number;\n};\n\n/**\n * Simple Key Value store\n * Defaults to `'auth-client-db'` with an object store of `'ic-keyval'`\n */\nexport class IdbKeyVal {\n  /**\n   * @param {DBCreateOptions} options - DBCreateOptions\n   * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database\n   * @default\n   * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store\n   * @default\n   * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade\n   * @constructs an {@link IdbKeyVal}\n   */\n  public static async create(options?: DBCreateOptions): Promise<IdbKeyVal> {\n    const { dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version = DB_VERSION } = options ?? {};\n    const db = await _openDbStore(dbName, storeName, version);\n    return new IdbKeyVal(db, storeName);\n  }\n\n  // Do not use - instead prefer create\n  private constructor(private _db: Database, private _storeName: string) {}\n\n  /**\n   * Basic setter\n   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n   * @param value value to set\n   * @returns void\n   */\n  public async set<T>(key: IDBValidKey, value: T) {\n    return await _setValue<T>(this._db, this._storeName, key, value);\n  }\n  /**\n   * Basic getter\n   * Pass in a type T for type safety if you know the type the value will have if it is found\n   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n   * @returns `Promise<T | null>`\n   * @example\n   * await get<string>('exampleKey') -> 'exampleValue'\n   */\n  public async get<T>(key: IDBValidKey): Promise<T | null> {\n    return (await _getValue<T>(this._db, this._storeName, key)) ?? null;\n  }\n\n  /**\n   * Remove a key\n   * @param key {@link IDBValidKey}\n   * @returns void\n   */\n  public async remove(key: IDBValidKey) {\n    return await _removeValue(this._db, this._storeName, key);\n  }\n}\n", "import { DBCreateOptions, IdbKeyVal } from './db';\n\nexport const KEY_STORAGE_KEY = 'identity';\nexport const KEY_STORAGE_DELEGATION = 'delegation';\nexport const KEY_VECTOR = 'iv';\n// Increment if any fields are modified\nexport const DB_VERSION = 1;\n\nexport const isBrowser = typeof window !== 'undefined';\n\nexport type StoredKey = string | CryptoKeyPair;\n\n/**\n * Interface for persisting user authentication data\n */\nexport interface AuthClientStorage {\n  get(key: string): Promise<StoredKey | null>;\n\n  set(key: string, value: StoredKey): Promise<void>;\n\n  remove(key: string): Promise<void>;\n}\n\n/**\n * Legacy implementation of AuthClientStorage, for use where IndexedDb is not available\n */\nexport class LocalStorage implements AuthClientStorage {\n  constructor(public readonly prefix = 'ic-', private readonly _localStorage?: Storage) {}\n\n  public get(key: string): Promise<string | null> {\n    return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));\n  }\n\n  public set(key: string, value: string): Promise<void> {\n    this._getLocalStorage().setItem(this.prefix + key, value);\n    return Promise.resolve();\n  }\n\n  public remove(key: string): Promise<void> {\n    this._getLocalStorage().removeItem(this.prefix + key);\n    return Promise.resolve();\n  }\n\n  private _getLocalStorage() {\n    if (this._localStorage) {\n      return this._localStorage;\n    }\n\n    const ls =\n      typeof window === 'undefined'\n        ? typeof global === 'undefined'\n          ? typeof self === 'undefined'\n            ? undefined\n            : self.localStorage\n          : global.localStorage\n        : window.localStorage;\n\n    if (!ls) {\n      throw new Error('Could not find local storage.');\n    }\n\n    return ls;\n  }\n}\n\n/**\n * IdbStorage is an interface for simple storage of string key-value pairs built on {@link IdbKeyVal}\n *\n * It replaces {@link LocalStorage}\n * @see implements {@link AuthClientStorage}\n */\nexport class IdbStorage implements AuthClientStorage {\n  #options: DBCreateOptions;\n\n  /**\n   * @param options - DBCreateOptions\n   * @param options.dbName - name for the indexeddb database\n   * @param options.storeName - name for the indexeddb Data Store\n   * @param options.version - version of the database. Increment to safely upgrade\n   * @constructs an {@link IdbStorage}\n   * @example\n   * ```typescript\n   * const storage = new IdbStorage({ dbName: 'my-db', storeName: 'my-store', version: 2 });\n   * ```\n   */\n  constructor(options?: DBCreateOptions) {\n    this.#options = options ?? {};\n  }\n\n  // Initializes a KeyVal on first request\n  private initializedDb: IdbKeyVal | undefined;\n  get _db(): Promise<IdbKeyVal> {\n    return new Promise(resolve => {\n      if (this.initializedDb) {\n        resolve(this.initializedDb);\n        return;\n      }\n      IdbKeyVal.create(this.#options).then(db => {\n        this.initializedDb = db;\n        resolve(db);\n      });\n    });\n  }\n\n  public async get<T = string>(key: string): Promise<T | null> {\n    const db = await this._db;\n    return await db.get<T>(key);\n    // return (await db.get<string>(key)) ?? null;\n  }\n\n  public async set<T = string>(key: string, value: T): Promise<void> {\n    const db = await this._db;\n    await db.set(key, value);\n  }\n\n  public async remove(key: string): Promise<void> {\n    const db = await this._db;\n    await db.remove(key);\n  }\n}\n", "/** @module AuthClient */\nimport {\n  AnonymousIdentity,\n  DerEncodedPublicKey,\n  Identity,\n  Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport {\n  Delegation,\n  DelegationChain,\n  isDelegationValid,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  ECDSAKeyIdentity,\n  PartialDelegationIdentity,\n} from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager, IdleManagerOptions } from './idleManager';\nimport {\n  AuthClientStorage,\n  IdbStorage,\n  isBrowser,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n  KEY_VECTOR,\n  LocalStorage,\n} from './storage';\nimport { PartialIdentity } from '@dfinity/identity/lib/cjs/identity/partial';\n\nexport { AuthClientStorage, IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\nexport { IdbKeyVal, DBCreateOptions } from './db';\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\n\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\ntype BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\n\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An identity to use as the base\n   */\n  identity?: SignIdentity | PartialIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n   */\n  storage?: AuthClientStorage;\n  /**\n   * type to use for the base key\n   * @default 'ECDSA'\n   * If you are using a custom storage provider that does not support CryptoKey storage,\n   * you should use 'Ed25519' as the key type, as it can serialize to a string\n   */\n  keyType?: BaseKeyType;\n\n  /**\n   * Options to handle idle timeouts\n   * @default after 30 minutes, invalidates the identity\n   */\n  idleOptions?: IdleOptions;\n}\n\nexport interface IdleOptions extends IdleManagerOptions {\n  /**\n   * Disables idle functionality for {@link IdleManager}\n   * @default false\n   */\n  disableIdle?: boolean;\n\n  /**\n   * Disables default idle behavior - call logout & reload window\n   * @default false\n   */\n  disableDefaultIdleCallback?: boolean;\n}\n\nexport * from './idleManager';\n\nexport type OnSuccessFunc =\n  | (() => void | Promise<void>)\n  | ((message: InternetIdentityAuthResponseSuccess) => void | Promise<void>);\n\nexport type OnErrorFunc = (error?: string) => void | Promise<void>;\n\nexport interface AuthClientLoginOptions {\n  /**\n   * Identity provider\n   * @default \"https://identity.ic0.app\"\n   */\n  identityProvider?: string | URL;\n  /**\n   * Expiration of the authentication in nanoseconds\n   * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   */\n  allowPinAuthentication?: boolean;\n  /**\n   * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n   * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n   */\n  derivationOrigin?: string | URL;\n  /**\n   * Auth Window feature config string\n   * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n   */\n  windowOpenerFeatures?: string;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: OnSuccessFunc;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: OnErrorFunc;\n  /**\n   * Extra values to be passed in the login request during the authorize-ready phase\n   */\n  customValues?: Record<string, unknown>;\n}\n\ninterface InternetIdentityAuthRequest {\n  kind: 'authorize-client';\n  sessionPublicKey: Uint8Array;\n  maxTimeToLive?: bigint;\n  allowPinAuthentication?: boolean;\n  derivationOrigin?: string;\n}\n\nexport interface InternetIdentityAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\ninterface AuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\ntype IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\ntype AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @constructs\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegration credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  public static async create(\n    options: {\n      /**\n       * An {@link SignIdentity} or {@link PartialIdentity} to authenticate via delegation.\n       */\n      identity?: SignIdentity | PartialIdentity;\n      /**\n       * {@link AuthClientStorage}\n       * @description Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n       */\n      storage?: AuthClientStorage;\n      /**\n       * type to use for the base key\n       * @default 'ECDSA'\n       * If you are using a custom storage provider that does not support CryptoKey storage,\n       * you should use 'Ed25519' as the key type, as it can serialize to a string\n       */\n      keyType?: BaseKeyType;\n      /**\n       * Options to handle idle timeouts\n       * @default after 10 minutes, invalidates the identity\n       */\n      idleOptions?: IdleOptions;\n    } = {},\n  ): Promise<AuthClient> {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n\n    let key: null | SignIdentity | PartialIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch (e) {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity: SignIdentity | PartialIdentity = new AnonymousIdentity() as PartialIdentity;\n    let chain: null | DelegationChain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error(\n            'Delegation chain is incorrectly stored. A delegation chain should be stored as a string.',\n          );\n        }\n\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager: IdleManager | undefined = undefined;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = await Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify((key as Ed25519KeyIdentity).toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(\n            `You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`,\n          );\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, (key as ECDSAKeyIdentity).getKeyPair());\n      }\n    }\n\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n\n  protected constructor(\n    private _identity: Identity | PartialIdentity,\n    private _key: SignIdentity | PartialIdentity,\n    private _chain: DelegationChain | null,\n    private _storage: AuthClientStorage,\n    public idleManager: IdleManager | undefined,\n    private _createOptions: AuthClientCreateOptions | undefined,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) {\n    this._registerDefaultIdleCallback();\n  }\n\n  private _registerDefaultIdleCallback() {\n    const idleOptions = this._createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n\n  private async _handleSuccess(\n    message: InternetIdentityAuthResponseSuccess,\n    onSuccess?: OnSuccessFunc,\n  ) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(\n          signedDelegation.delegation.pubkey,\n          signedDelegation.delegation.expiration,\n          signedDelegation.delegation.targets,\n        ),\n        signature: signedDelegation.signature.buffer as Signature,\n      };\n    });\n\n    const delegationChain = DelegationChain.fromDelegations(\n      delegations,\n      message.userPublicKey.buffer as DerEncodedPublicKey,\n    );\n\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n\n    this._chain = delegationChain;\n\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n\n    this._idpWindow?.close();\n    const idleOptions = this._createOptions?.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !idleOptions?.disableIdle) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n\n    this._removeEventListener();\n    delete this._idpWindow;\n\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.(message);\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n\n  /**\n   * AuthClient Login -\n   * Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  public async login(options?: AuthClientLoginOptions): Promise<void> {\n    // Set default maxTimeToLive to 8 hours\n    const defaultTimeToLive = /* hours */ BigInt(8) * /* nanoseconds */ BigInt(3_600_000_000_000);\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(\n      options?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT,\n    );\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive: options?.maxTimeToLive ?? defaultTimeToLive,\n      ...options,\n    });\n    window.addEventListener('message', this._eventHandler);\n\n    // Open a new window with the IDP provider.\n    this._idpWindow =\n      window.open(identityProviderUrl.toString(), 'idpWindow', options?.windowOpenerFeatures) ??\n      undefined;\n\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, options?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n\n  private _getEventHandler(identityProviderUrl: URL, options?: AuthClientLoginOptions) {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        console.warn(\n          `WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`,\n        );\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest = {\n            kind: 'authorize-client',\n            sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer() as ArrayBuffer),\n            maxTimeToLive: options?.maxTimeToLive,\n            allowPinAuthentication: options?.allowPinAuthentication,\n            derivationOrigin: options?.derivationOrigin?.toString(),\n            // Pass any custom values to the IDP.\n            ...options?.customValues,\n          };\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure((err as Error).message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): void {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    await _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch (e) {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\nasync function _deleteStorage(storage: AuthClientStorage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\n"],
  "mappings": "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",
  "names": ["target"]
}
